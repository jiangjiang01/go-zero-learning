version: '3.8'

services:
  # MySQL 数据库
  mysql:
    image: mysql:8.0  # 指定使用 MySQL 8.0 版本官方镜像
    container_name: go-zero-mysql  # 设置容器名称，方便后续管理和调用
    environment:
      MYSQL_ROOT_PASSWORD: 123456  # 设置 MySQL root 用户的初始密码
      MYSQL_DATABASE: testdb       # 初始化时自动创建的数据库名称
      TZ: Asia/Shanghai            # 设置容器的时区为上海，保证时间一致性
    ports:
      - "3307:3306" # 将主机的 3307 端口映射到容器的 3306 端口，避免与本地已有 MySQL 冲突
    volumes:
      - mysql_data:/var/lib/mysql # 使用 Docker 卷持久化 MySQL 数据，防止数据丢失
      - ./scripts/init_test_data.sql:/docker-entrypoint-initdb.d/init.sql:ro # 启动时自动导入初始化 SQL 脚本（只读挂载）
    command: --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci  # 配置默认字符集及排序规则为 utf8mb4，支持 Emoji 和多语言
    networks:
      - go-zero-network # 加入自定义网络，便于与其他服务（如后端、前端等）互联互通
    healthcheck: # 健康检查，确保数据库准备就绪后再被依赖服务访问
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost", "-u", "root", "-p123456"] # 使用 mysqladmin 工具检测数据库活性
      interval: 10s   # 健康检查的时间间隔
      timeout: 5s     # 健康检查超时时间
      retries: 5      # 重试次数

  # Redis 缓存服务
  redis:
    image: redis:7-alpine   # 指定使用 Redis 7 的 Alpine 精简官方镜像，减小体积便于部署
    container_name: go-zero-redis  # 设置 Redis 容器名称，方便后续管理和调用
    ports:
      - "6379:6379" # 将主机的 6379 端口映射到容器的 6379 端口，允许本机和其他容器访问 Redis 服务
    volumes:
      - redis_data:/data # 将 Redis 数据持久化到 Docker 卷 redis_data，防止数据丢失，实现断电/重启后的数据恢复
    networks:
      - go-zero-network # 加入自定义网络，允许与其他服务（如后端服务、管理面板等）互通
    command: redis-server --appendonly yes # 以 AOF 模式启动 Redis，记录每次写操作日志，提升数据安全，减少因意外宕机造成的数据丢失
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]    # 使用 redis-cli 工具通过 ping 命令检测服务是否可用，"PONG" 则健康
      interval: 5s      # 每隔 5 秒执行一次健康检查
      timeout: 3s       # 单次健康检查最长等待时间为 3 秒
      retries: 5        # 连续检查失败 5 次后认定服务不健康

  # 用户 RPC 服务（User Service，负责用户相关的远程过程调用，主要处理用户信息、登录注册等业务逻辑）
  user-rpc:
    build:
      context: ./backend                     # 指定构建上下文目录，即包含 Dockerfile 和 Go 源码的位置
      dockerfile: Dockerfile.user-rpc        # 明确指定用于构建该服务的 Dockerfile（自定义用户RPC的Build流程）
    container_name: go-zero-user-rpc         # 容器的自定义名称，便于后续容器管理与运维排查
    ports:
      - "8081:8081"                          # 将主机 8081 端口映射到容器 8081 端口，对外暴露 RPC 服务接口
    volumes:
      - ./docker/config/userrpc.yaml:/app/etc/userrpc.yaml:ro  # 只读方式挂载用户RPC的配置文件（防配置意外更改）
      - user-rpc-logs:/app/logs                              # 将应用内部日志目录持久化到 Docker 卷，防止日志丢失
    networks:
      - go-zero-network                      # 加入自定义网络，使服务内部可用服务名互相访问
    depends_on:                              # 明确声明依赖，确保数据库/缓存服务准备就绪后再启动该服务
      mysql:
        condition: service_healthy           # 仅在 MySQL 健康检查通过后启动
      redis:
        condition: service_healthy           # 仅在 Redis 健康检查通过后启动
    restart: unless-stopped                  # 若容器异常退出则自动重启，除非手动停止，提升稳定性

  # 商品 RPC 服务（Product Service，负责产品相关的远程过程调用，如商品信息的增删改查等）
  product-rpc:
    build:
      context: ./backend                     # 指定构建上下文（与 user-rpc 保持一致，复用同一代码仓库）
      dockerfile: Dockerfile.product-rpc     # 指定商品服务专用 Dockerfile（Product服务独立构建）
    container_name: go-zero-product-rpc      # 自定义容器名称，区分不同微服务
    ports:
      - "8082:8082"                          # 将主机 8082 端口映射到容器 8082 端口，对外暴露 RPC 服务接口
    volumes:
      - ./docker/config/productrpc.yaml:/app/etc/productrpc.yaml:ro  # 只读方式挂载商品RPC配置文件，保障配置安全
      - product-rpc-logs:/app/logs                            # 应用日志持久化目录，方便日志采集与排查故障
    networks:
      - go-zero-network                      # 同样加入统一网络，便于服务间点对点通信
    depends_on:                              # 等待依赖服务健康后启动，避免 RPC 服务连接异常
      mysql:
        condition: service_healthy           # 依赖 mysql，等待健康检查通过
      redis:
        condition: service_healthy           # 依赖 redis，确保缓存可用
    restart: unless-stopped                  # 自动重启策略，保障服务高可用
  
  # 用户 API 服务配置
  #
  # 该服务负责对外提供与用户有关的 HTTP API（如注册、登录、资料查询等），
  # 实现了将前端的 HTTP 请求转发到后端逻辑，并依赖其他微服务（如 user-rpc、product-rpc）
  # 以实现更高效的分布式业务处理。
  user-api:
    build:
      context: ./backend                # 指定 Docker build 上下文，包含 Go 源码和相关依赖
      dockerfile: Dockerfile.user-api   # 使用专用 Dockerfile，独立构建 user-api 可执行文件
    container_name: go-zero-user-api    # 设定易识别的容器名，方便运维排查与日志定位

    # 端口映射：
    # - 将宿主机 8888 端口映射到容器的 8888 端口
    # - 以便前端或其他服务能够通过 http://localhost:8888 访问用户接口
    ports:
      - "8888:8888"

    # 卷挂载配置：
    # 1. 配置文件挂载（只读）：保证容器运行时读取到最新的用户 API 配置，防止容器内配置丢失或误改。
    # 2. 日志持久化：将应用产生的日志同步到外部卷，便于容器重启后的日志保留及分析审计。
    # 3. 上传目录持久化：用户上传的文件不会因容器销毁而丢失，数据可持久保存于 Docker 管理的数据卷。
    volumes:
      - ./docker/config/user-api.yaml:/app/etc/user-api.yaml:ro
      - user-api-logs:/app/logs
      - user-api-uploads:/app/uploads

    # 网络配置：
    # - 加入自定义 go-zero-network 网络，使本服务可通过服务名与 MySQL、Redis 及其他后端微服务互联
    networks:
      - go-zero-network

    # 依赖声明（服务启动顺序和健康检查）：
    # - 明确指明依赖于 mysql、redis、user-rpc、product-rpc
    # - 其中 mysql/redis 必须健康才启动本服务，以避免数据库/缓存不可用引起的异常。
    # - user-rpc/product-rpc 只需已启动即可，因为两者间协议通常为 RPC 内部调用
    depends_on:
      mysql:
        condition: service_healthy        # 等数据库健康检查通过
      redis:
        condition: service_healthy        # 等缓存服务健康检查通过
      user-rpc:
        condition: service_started        # 只需 user-rpc 服务已启动即可
      product-rpc:
        condition: service_started        # 只需 product-rpc 服务已启动即可

    # 重启策略：
    # - unless-stopped：若因异常退出会自动重启，除非用户主动停止。此策略提升 API 服务的高可用性。
    restart: unless-stopped

  # 前端服务
  frontend:
    build:
      context: ./frontend                  # 前端项目源码目录，包含 Dockerfile
      dockerfile: Dockerfile               # 前端服务的多阶段构建 Dockerfile
    container_name: go-zero-frontend       # 容器名称，便于本地和生产环境识别
    ports:
      - "80:80"                            # 映射宿主机 80 端口到容器（Nginx）80 端口，供外部访问
    volumes:
      - ./docker/nginx.conf:/etc/nginx/conf.d/default.conf:ro   # 挂载自定义 Nginx 配置为只读，便于热更新前端路由与代理规则
    networks:
      - go-zero-network                    # 使用 go-zero-network 网络，便于与后端等服务互联
    depends_on:
      - user-api                           # 等 user-api 启动后再启动前端，确保接口联通
    restart: unless-stopped                # 服务异常退出会自动重启，提升可用性

# ======================== 自定义网络配置 ========================
networks:
  go-zero-network:
    driver: bridge            # 使用 bridge 桥接网络驱动，实现容器间通信与互联
    # 该自定义网络用于将涉及的服务（mysql、redis、后端、前端等）统一纳入同一网络空间
    # 这样它们可以通过服务名直接互相访问，避免暴露内部端口到主机
    # 可根据需求配置其他网络参数，如子网等

# ======================== 数据卷（持久化存储） ========================
volumes:
  mysql_data:                 # MySQL 数据卷，持久化存储数据库文件
    # 使用 Docker Volume 机制，确保即使容器被删除数据依然保留
    # 默认路径由 Docker 管理，也可以通过 driver/options 自定义存储路径
  redis_data:                 # Redis 数据卷，用于持久化 Redis 持久化文件
    # Redis 运行时的数据、AOF 文件等会保存在该卷中，实现断电和重启后的数据恢复